# 🔐 АУДИТ АВТОРИЗАЦИИ И АУТЕНТИФИКАЦИИ

**Дата аудита:** 2025-01-29  
**Версия системы:** Production  
**Аудитор:** Senior Security Engineer

---

## 📊 СВОДНАЯ ТАБЛИЦА ПРОВЕРОК

| Категория | Проверка | Статус | Комментарий / Риск |
|-----------|----------|--------|-------------------|
| **🏗️ Архитектура** |
| Метод аутентификации | Email-based одноразовые коды | ✅ | Без паролей, более безопасно |
| Интеграция Frontend/Backend | JWT в HttpOnly cookies | ✅ | Корректная интеграция |
| Защита API endpoints | Middleware на всех /api/* | ✅ | Публичные пути определены |
| Обходные пути | Открытые эндпоинты | ⚠️ | `/api/auth/*` публичны (нормально) |
| **📝 Регистрация и вход** |
| Валидация email | Regex + нормализация | ✅ | Корректная валидация |
| Rate limit для входа | 5 попыток/мин на IP | ✅ | Реализовано через Upstash |
| Защита от timing attacks | Базовая задержка 500ms | ✅ | Есть в send-code |
| Сообщения об ошибках | Унифицированные ответы | ✅ | Не раскрывает существование email |
| Создание пользователя | upsertUser | ✅ | Автоматическое при первом входе |
| **🔑 Токены и сессии** |
| Access токен | JWT, 15 минут | ✅ | Короткий TTL |
| Refresh токен | JWT, 7 дней, в БД | ✅ | Долгий TTL, хранится в БД |
| Хранение токенов | HttpOnly cookies | ✅ | Защита от XSS |
| Обновление токена | Auto-refresh при 401 | ✅ | В api-client.ts |
| Ротация refresh | Включена по умолчанию | ✅ | По умолчанию включена, можно отключить через env |
| Отзыв refresh токена | Удаление из БД при logout | ✅ | Реализовано |
| Проверка в middleware | На каждом запросе | ✅ | Полная проверка |
| **👥 Роли и права** |
| Назначение ролей | При создании (env ADMIN_EMAIL) | ✅ | Автоматически |
| Проверка на backend | Middleware + getCurrentUser | ✅ | Двойная проверка |
| Admin endpoints | Проверка role === 'admin' | ✅ | Во всех админских роутах |
| Временный доступ | accessFrom/accessUntil | ✅ | Проверяется в middleware |
| Демо-лимит | documentsUsed/Limit | ✅ | Проверяется при создании документа |
| **❌ Ошибки и исключения** |
| HTTP статусы | 401, 403, 429, 400, 500 | ✅ | Корректное использование |
| Утечка информации | Stack trace не возвращается | ✅ | Только общие сообщения |
| Ошибки валидации | Zod с детальными сообщениями | ✅ | Для форм - нормально |
| Обработка 401/403 | Редирект на /auth/login | ✅ | В api-client.ts |
| **📋 Логи и аудит** |
| Логирование входов | Нет централизованного | ❌ | Нет структурированного лога |
| Логирование блокировок | Нет | ❌ | Только console.error |
| Подозрительная активность | Нет отслеживания | ❌ | Нет системы обнаружения |
| Хранение паролей в логах | Нет паролей | ✅ | Используются коды |
| Sentry интеграция | Есть | ✅ | Но только для ошибок, не для security events |
| **🎨 UX-поведение** |
| Обработка неверного кода | Унифицированное сообщение | ✅ | "Неверный или истекший код" |
| Истекший токен | Auto-refresh | ✅ | Прозрачно для пользователя |
| Автоматический logout | При 401 после refresh | ✅ | Редирект на /auth/login |
| Обновление без потери сессии | Refresh flow | ✅ | Работает корректно |
| Повторные запросы | Защита от двойного submit | ⚠️ | Зависит от UI (loading state) |
| **🛡️ Уязвимости** |
| XSS | HttpOnly cookies | ✅ | Защищено |
| CSRF | SameSite strict cookies | ⚠️ | Частично защищено, нет CSRF токенов |
| Session fixation | Новая сессия при входе | ✅ | JWT генерируется заново |
| Повторное использование токенов | Refresh rotation включена | ✅ | По умолчанию включена для безопасности |
| Валидация форм | Zod схемы | ✅ | На всех критичных endpoints |
| SQL Injection | Prisma ORM | ✅ | Параметризованные запросы |
| **🔄 Refresh Flow** |
| Механизм обновления | POST /api/auth/refresh | ✅ | Реализован |
| Отзыв при logout | revokeRefreshToken | ✅ | Работает |
| Отзыв всех токенов | При смене email | ✅ | revokeAllUserRefreshTokens |
| Проверка роли в refresh | Сравнение роли из БД | ✅ | Обнаруживает изменение роли |
| **📧 Email-верификация** |
| Подтверждение email | Автоматически true при входе | ⚠️ | Нет явной верификации |
| Смена email | Код на новый email | ✅ | verify-email-change endpoint |
| Защита от перечисления | Унифицированные ответы | ✅ | Не раскрывает существование |

---

## 🔍 ДЕТАЛЬНЫЙ АНАЛИЗ

### 1. Архитектура авторизации ✅

**Метод аутентификации:** Email-based с одноразовыми 6-значными кодами  
**Преимущества:**
- Нет паролей → нет риска утечки хэшей
- Более безопасно для пользователей
- Email уже верифицирован (получен код)

**Архитектура:**
```
Frontend → POST /api/auth/send-code → Email с кодом
         → POST /api/auth/verify-code → JWT токены в cookies
         → Все последующие запросы → Middleware проверяет JWT
```

**Middleware:**
- ✅ Проверяет токен на всех `/api/*` путях
- ✅ Пропускает только публичные: `/api/auth/send-code`, `/api/auth/verify-code`, `/api/auth/refresh`
- ✅ Проверяет роль для `/api/admin/*`
- ✅ Проверяет временный доступ для обычных пользователей

**✅ Сильные стороны:**
- Централизованная проверка в middleware
- Все API endpoints защищены по умолчанию
- Роли проверяются на уровне middleware и в роутах

---

### 2. Токены и сессии ✅

**Access Token:**
- Формат: JWT
- Время жизни: 15 минут (configurable через `JWT_EXPIRES_IN`)
- Хранение: HttpOnly cookie `token`
- Алгоритм: HS256 (через jsonwebtoken)

**Refresh Token:**
- Формат: JWT
- Время жизни: 7 дней
- Хранение: HttpOnly cookie `refreshToken` + запись в БД (таблица `RefreshToken`)
- Отзыв: Флаг `revoked` в БД

**Безопасность cookies:**
```typescript
{
  httpOnly: true,        // ✅ Защита от XSS
  secure: isProduction,   // ✅ HTTPS только в production
  sameSite: 'strict'     // ✅ Защита от CSRF (частично)
}
```

**Refresh Flow:**
```typescript
1. Access token истек → 401
2. api-client.ts автоматически вызывает /api/auth/refresh
3. Проверяется refresh token в БД
4. Выдается новый access token
5. Ротация refresh token (включена по умолчанию)
   - Старый refresh token отзывается в БД
   - Создается новый refresh token
   - Можно отключить через ROTATE_REFRESH_TOKENS=false
```

**⚠️ Проблемы:**

1. **Нет явного отзыва access токена**
   - Доступно только через logout (отзыв refresh токена)
   - Access token валиден до истечения TTL (15 мин)

**✅ Сильные стороны:**
- Refresh токены хранятся в БД с возможностью отзыва
- При смене email все refresh токены отзываются
- При изменении роли refresh токен становится невалидным
- Автоматический refresh при 401 на клиенте

---

### 3. Роли и права ✅

**Роли:**
- `admin` - получает при совпадении email с `ADMIN_EMAIL`
- `user` - по умолчанию для всех остальных

**Проверка ролей:**

1. **Middleware уровень:**
```typescript
if (ADMIN_PATHS.some(path => pathname.startsWith(path))) {
  if (payload.role !== 'admin') {
    return 403 Forbidden;
  }
}
```

2. **Route уровень:**
```typescript
const user = await getCurrentUser(request);
if (!user) return 401;
if (user.role !== 'admin') return 403;
```

**✅ Двойная проверка:** Middleware + Route handler

**Временный доступ:**
- Поля `accessFrom` и `accessUntil` в таблице `User`
- Проверяется в middleware для роли `user`
- Админы имеют неограниченный доступ

**Демо-лимит:**
- Проверяется при создании документа
- `documentsUsed < documentsLimit`
- Логика: если нет временного доступа, используется демо-лимит

**✅ Сильные стороны:**
- Роли проверяются на двух уровнях
- Доступ администратора проверяется везде
- Временный доступ интегрирован в middleware

---

### 4. Защита от атак ✅

**XSS (Cross-Site Scripting):**
- ✅ HttpOnly cookies → JS не может прочитать токены
- ✅ React санитизация (Next.js по умолчанию)

**CSRF (Cross-Site Request Forgery):**
- ⚠️ `SameSite: 'strict'` → частичная защита
- ❌ Нет CSRF токенов для дополнительной защиты
- ⚠️ Не защищает от cross-origin POST запросов в некоторых сценариях

**Timing Attacks:**
- ✅ Базовая защита в `/api/auth/send-code`:
```typescript
const baseDelay = 500; // Базовая задержка
await new Promise(resolve => setTimeout(resolve, baseDelay));
```
- ✅ Всегда возвращается одинаковый успешный ответ, независимо от существования пользователя

**User Enumeration:**
- ✅ Унифицированные ответы в `/api/auth/send-code`
- ✅ Не раскрывает, существует ли email в системе
- ✅ Код генерируется всегда, даже если пользователя нет

**SQL Injection:**
- ✅ Prisma ORM → параметризованные запросы
- ✅ Нет прямой конкатенации SQL

**Rate Limiting:**
- ✅ Общий API: 100 запросов/мин на IP
- ✅ Авторизация: 5 попыток/мин на IP
- ⚠️ Использует Upstash Redis (если не настроен, rate limit отключен)

---

### 5. Обработка ошибок ✅

**HTTP статусы:**
- ✅ `401 Unauthorized` - нет токена или невалидный
- ✅ `403 Forbidden` - недостаточно прав или истек доступ
- ✅ `429 Too Many Requests` - превышен rate limit
- ✅ `400 Bad Request` - валидация данных
- ✅ `500 Internal Server Error` - серверные ошибки

**Информационная безопасность:**
- ✅ Stack trace не возвращается клиенту
- ✅ Общие сообщения об ошибках
- ✅ Детальные ошибки валидации только для форм (нормально)

**Пример безопасного ответа:**
```typescript
return NextResponse.json(
  { error: 'Internal server error' },
  { status: 500 }
);
// ❌ НЕ возвращается: error.stack, error.message (технические детали)
```

**Frontend обработка:**
- ✅ Автоматический refresh при 401
- ✅ Редирект на `/auth/login` если refresh не удался
- ✅ Сохранение `next` параметра для редиректа после входа

---

### 6. Логирование и аудит ❌

**Текущее состояние:**

**Есть:**
- ✅ `console.error` в catch блоках
- ✅ Sentry интеграция для ошибок
- ✅ История изменений доступа (`AccessHistory` таблица)

**Нет:**
- ❌ Структурированного логирования security events:
  - Неудачные попытки входа
  - Неавторизованные запросы к защищенным endpoints
  - Изменение ролей
  - Массовые запросы (возможная атака)
- ❌ Централизованной системы аудита
- ❌ Alerting при подозрительной активности

**Риски:**
- Нет отслеживания brute-force атак
- Невозможно определить patterns атак постфактум
- Нет мониторинга необычной активности

**Рекомендации:**
1. Добавить таблицу `SecurityLog` в БД:
```prisma
model SecurityLog {
  id          String   @id @default(uuid())
  eventType   String   // "failed_login", "unauthorized_access", "rate_limit_exceeded"
  userId      String?
  ip          String
  userAgent   String?
  details     Json?
  createdAt   DateTime @default(now())
  
  @@index([eventType])
  @@index([ip])
  @@index([createdAt])
}
```

2. Логировать события в middleware и auth endpoints
3. Настроить alerting в Sentry для критичных событий

---

### 7. UX и поведение ✅

**Вход:**
- ✅ Двухэтапный процесс (email → код)
- ✅ Показ кода в development режиме (для тестирования)
- ✅ Автоматический редирект после успешного входа
- ✅ Сохранение состояния в React Query

**Обработка истекшего токена:**
- ✅ Автоматический refresh без потери сессии
- ✅ Прозрачно для пользователя
- ✅ Редирект только если refresh не удался

**Обработка ошибок:**
- ✅ Унифицированные сообщения пользователю
- ✅ Toast уведомления для успеха/ошибок
- ✅ Disabled состояние кнопок во время запросов

**⚠️ Проблемы:**

1. **Нет явной верификации email**
   - Поле `emailVerified` всегда `true` при входе
   - Нет механизма подтверждения email после регистрации
   - Риск: Email может быть неверным или не принадлежать пользователю

2. **Зависимость от UI для предотвращения двойного submit**
   - Защита только через `loading` state
   - Можно обойти, отключив JS

**Рекомендации:**
1. Добавить механизм верификации email (отправка письма при первом входе)
2. Добавить server-side защиту от двойного submit (idempotency keys)

---

### 8. Email-верификация ⚠️

**Текущая реализация:**
- При входе `emailVerified` устанавливается в `true`
- Нет явной верификации email

**Смена email:**
- ✅ Корректно реализована через `/api/users/verify-email-change`
- ✅ Отправляется код на новый email
- ✅ При успешной смене все refresh токены отзываются

**⚠️ Проблема:**
- При регистрации email считается верифицированным без подтверждения
- Риск: Email может быть неверным или поддельным

**Рекомендация:**
Добавить явную верификацию email при первом входе:
1. После входа по коду, если `emailVerified === false`, отправить верификационное письмо
2. Блокировать доступ к основному функционалу до верификации
3. Или добавить ограничения для неверифицированных пользователей

---

## 🚨 КРИТИЧНЫЕ ПРОБЛЕМЫ

### 1. ❌ Отсутствие логирования security events

**Риск:** Высокий  
**Описание:** Невозможно отследить:
- Неудачные попытки входа
- Попытки перебора кодов
- Неавторизованные запросы
- Подозрительную активность

**Решение:**
Добавить структурированное логирование всех security events.

---

### 2. ⚠️ CSRF защита неполная

**Риск:** Средний  
**Описание:** `SameSite: strict` защищает от большинства CSRF атак, но не от всех сценариев.

**Решение:**
- Добавить CSRF токены для state-changing операций (POST/PUT/DELETE)
- Или использовать double-submit cookie pattern

---

### 3. ⚠️ Email не верифицируется явно

**Риск:** Низкий  
**Описание:** При входе email автоматически считается верифицированным, хотя пользователь мог ввести чужой email.

**Решение:**
Добавить явную верификацию email после первого входа.

---

## ✅ РЕКОМЕНДАЦИИ ПО УЛУЧШЕНИЮ

### Высокий приоритет

1. **Добавить логирование security events**
   - Таблица `SecurityLog` в БД
   - Логирование в middleware и auth endpoints
   - Интеграция с Sentry для критичных событий

2. ~~**Включить ротацию refresh токенов в production**~~ ✅ **ИСПРАВЛЕНО**
   - Ротация теперь включена по умолчанию
   - Можно отключить через `ROTATE_REFRESH_TOKENS=false` (не рекомендуется)

3. **Улучшить CSRF защиту**
   - Добавить CSRF токены для state-changing операций
   - Или использовать более строгий SameSite policy

### Средний приоритет

4. **Добавить явную верификацию email**
   - Отправка верификационного письма после первого входа
   - Ограничение функционала до верификации

5. **Улучшить обработку rate limit**
   - Настроить Upstash Redis в production
   - Добавить exponential backoff для клиентов

6. **Добавить server-side защиту от двойного submit**
   - Idempotency keys для критичных операций
   - Кеширование результатов на короткое время

### Низкий приоритет

7. **Улучшить мониторинг**
   - Dashboard для security events
   - Alerting при подозрительной активности
   - Метрики по входам/выходам

8. **Добавить 2FA (опционально)**
   - Для администраторов
   - TOTP через Google Authenticator

---

## 📈 ИТОГОВАЯ ОЦЕНКА

**Общая оценка безопасности:** **8.0/10** ⬆️ (было 7.5/10)

**Разбивка:**
- Архитектура: ✅ 9/10
- Токены и сессии: ✅ 9/10 ⬆️ (было 8/10 - исправлена ротация)
- Роли и права: ✅ 9/10
- Защита от атак: ⚠️ 7/10 (CSRF частично)
- Обработка ошибок: ✅ 9/10
- Логирование: ❌ 3/10
- UX: ✅ 8/10

**Сильные стороны:**
- ✅ Хорошая архитектура с централизованной проверкой
- ✅ Безопасное хранение токенов (HttpOnly cookies)
- ✅ Двойная проверка ролей
- ✅ Защита от timing attacks и user enumeration
- ✅ Корректная обработка ошибок

**Слабые стороны:**
- ❌ Отсутствие логирования security events
- ⚠️ Неполная CSRF защита

**Вывод:** Система имеет хорошую базовую безопасность, но требует улучшений в логировании и мониторинге для production использования.

---

## 📝 ЧЕКЛИСТ ДЛЯ PRODUCTION

- [x] JWT секретный ключ установлен и достаточно сложный (min 32 символа)
- [x] HttpOnly cookies используются
- [x] Secure flag включен в production
- [x] SameSite policy настроена
- [x] Rate limiting настроен
- [x] Middleware защищает все API endpoints
- [ ] Логирование security events
- [x] Ротация refresh токенов включена (включена по умолчанию)
- [ ] CSRF токены для state-changing операций
- [ ] Мониторинг подозрительной активности
- [ ] Настроен Upstash Redis для rate limiting
- [ ] Sentry настроен для security events

---

**Аудит выполнен:** 2025-01-29  
**Следующий аудит рекомендуется:** После внедрения критичных исправлений

