[
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "055a052f-acff-420c-8733-81081fba85be",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC001-send_verification_code_to_email",
    "description": "Test sending a 6-digit verification code to a valid email address. Verify rate limiting is enforced and security measures prevent timing attacks. Check response for success and token presence.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nENDPOINT = \"/api/auth/send-code\"\nFULL_URL = BASE_URL + ENDPOINT\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\n\ndef test_send_verification_code_to_email():\n    email = \"testuser@example.com\"\n    payload = {\"email\": email}\n\n    # Send first request to send code\n    response = requests.post(FULL_URL, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Expected 200 for first send, got {response.status_code}\"\n    data = response.json()\n    assert isinstance(data.get(\"success\"), bool), \"Response missing 'success' boolean\"\n    assert data.get(\"success\") is True, \"Expected success true in response\"\n    assert \"token\" in data and isinstance(data[\"token\"], str) and len(data[\"token\"]) > 0, \"Token missing or invalid in response\"\n    assert \"message\" in data and isinstance(data[\"message\"], str), \"Message missing or invalid in response\"\n\n    # Immediately send second request to test rate limiting\n    start_time = time.perf_counter()\n    response2 = requests.post(FULL_URL, json=payload, headers=HEADERS, timeout=TIMEOUT)\n    duration = time.perf_counter() - start_time\n\n    # Response time check to detect timing attack prevention (should be nearly constant and short)\n    assert duration < 5, f\"Response took too long: {duration} seconds, potential timing attack vulnerability\"\n\n    # Check expected status codes for rate limiting or success\n    if response2.status_code == 429:\n        # Rate limit enforced\n        # Optionally response body can be checked if available for indication\n        assert True\n    elif response2.status_code == 200:\n        data2 = response2.json()\n        assert isinstance(data2.get(\"success\"), bool), \"Second response missing 'success' boolean\"\n        assert \"token\" in data2 and isinstance(data2[\"token\"], str) and len(data2[\"token\"]) > 0, \"Second token missing or invalid\"\n    else:\n        assert False, f\"Unexpected status code {response2.status_code} on second request\"\n\n    # Check timing attack prevention by measuring multiple calls for consistent response duration\n    timings = []\n    for _ in range(3):\n        start = time.perf_counter()\n        r = requests.post(FULL_URL, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        r.raise_for_status()  # Raise for unexpected statuses\n        timings.append(time.perf_counter() - start)\n\n    max_diff = max(timings) - min(timings)\n    assert max_diff < 1.0, f\"Response times vary too much ({max_diff}s), potential timing attack risk\"\n\n\ntest_send_verification_code_to_email()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 56, in <module>\n  File \"<string>\", line 17, in test_send_verification_code_to_email\nAssertionError: Expected 200 for first send, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.636Z",
    "modified": "2025-10-30T02:42:34.732Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "32f9645c-f5fe-40ef-adfc-46e697329c52",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC002-verify_code_and_login_user",
    "description": "Test verifying the 6-digit code with correct and incorrect codes. Validate JWT token issuance, user creation or update, and HttpOnly cookie setting. Check for proper error responses on invalid code and rate limit exceeded.",
    "code": "import requests\nfrom requests.cookies import RequestsCookieJar\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_verify_code_and_login_user():\n    email = \"testuser@example.com\"\n    valid_code = None\n    session = requests.Session()\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Step 1: Send code to the email to get a valid code token from /api/auth/send-code\n    try:\n        send_code_resp = session.post(\n            f\"{BASE_URL}/api/auth/send-code\",\n            json={\"email\": email},\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert send_code_resp.status_code == 200, f\"Failed to send code: {send_code_resp.text}\"\n        send_code_data = send_code_resp.json()\n        assert send_code_data.get(\"success\") is True, \"Send code did not succeed\"\n        token = send_code_data.get(\"token\")\n        assert token and isinstance(token, str), \"No token returned for code sending\"\n\n        # Normally the 6-digit code is received by email; since we can't get it, assume a correct code exists for testing\n        # This token may be needed or authorized by system, here we test with a dummy valid code \"123456\"\n        # In a real integration environment, this step would capture or mock the actual code.\n        valid_code = \"123456\"\n\n        # Step 2: Verify code with correct code\n        verify_correct_resp = session.post(\n            f\"{BASE_URL}/api/auth/verify-code\",\n            json={\"email\": email, \"code\": valid_code},\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert verify_correct_resp.status_code == 200, f\"Correct code verification failed: {verify_correct_resp.text}\"\n\n        # Validate JWT token issuance and HttpOnly cookie setting\n        # Check JSON response success and presence of user object\n        verify_data = verify_correct_resp.json()\n        assert verify_data.get(\"success\") is True, \"Verify code success=false on correct code\"\n        assert \"user\" in verify_data and isinstance(verify_data[\"user\"], dict), \"User object missing or invalid\"\n\n        # Check for HttpOnly cookie set (JWT in cookie)\n        cookies = verify_correct_resp.cookies\n        has_httponly_jwt_cookie = False\n        for cookie in cookies:\n            if cookie.has_nonstandard_attr(\"HttpOnly\") or \"httponly\" in (cookie._rest or {}):\n                has_httponly_jwt_cookie = True\n                # Optionally check cookie name for JWT token presence or pattern\n                break\n        # Because RequestsCookieJar does not expose HttpOnly attribute easily,\n        # fallback: assume that cookie exists at all if headers contain set-cookie with HttpOnly\n        if not has_httponly_jwt_cookie:\n            set_cookie_header = verify_correct_resp.headers.get(\"set-cookie\", \"\")\n            has_httponly_jwt_cookie = \"httponly\" in set_cookie_header.lower()\n        assert has_httponly_jwt_cookie, \"No HttpOnly cookie set after successful verification\"\n\n        # Step 3: Verify code with incorrect code\n        wrong_code = \"000000\"\n        verify_wrong_resp = session.post(\n            f\"{BASE_URL}/api/auth/verify-code\",\n            json={\"email\": email, \"code\": wrong_code},\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert verify_wrong_resp.status_code == 400, f\"Invalid code did not return 400: {verify_wrong_resp.text}\"\n\n        # Step 4: Test rate limit exceeded - send multiple rapid requests with invalid codes to provoke 429\n        rate_limit_exceeded = False\n        for _ in range(10):\n            resp = session.post(\n                f\"{BASE_URL}/api/auth/verify-code\",\n                json={\"email\": email, \"code\": wrong_code},\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            if resp.status_code == 429:\n                rate_limit_exceeded = True\n                break\n        assert rate_limit_exceeded, \"Rate limit not enforced on excessive verify-code calls\"\n\n    finally:\n        session.close()\n\ntest_verify_code_and_login_user()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 89, in <module>\n  File \"<string>\", line 21, in test_verify_code_and_login_user\nAssertionError: Failed to send code: {\"success\":false,\"error\":\"Внутренняя ошибка сервера\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.642Z",
    "modified": "2025-10-30T02:42:34.700Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "44f47fc3-a432-4876-88d8-b5c43878b851",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC003-get_current_user_profile",
    "description": "Test retrieving the current authenticated user's profile. Validate response contains user details including id, email, firstName, lastName, and role. Check unauthorized access handling.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Placeholder credentials for authentication\nTEST_EMAIL = \"testuser@example.com\"\nTEST_CODE = \"123456\"  # This should match the actual code sent in a real test\n\ndef get_auth_token(email: str, code: str) -> str:\n    url = f\"{BASE_URL}/api/auth/verify-code\"\n    payload = {\"email\": email, \"code\": code}\n    headers = {\"Content-Type\": \"application/json\"}\n    response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    response.raise_for_status()\n    data = response.json()\n    if not data.get(\"success\") or \"user\" not in data:\n        raise Exception(\"Authentication failed\")\n    # Assuming the API responds with a Set-Cookie header containing HttpOnly cookie and does not return JWT in body\n    # To use bearer token style, usually token is returned; here assume cookies session based for requests\n    # If token is returned in response, get it accordingly. Since exact method not given, fallback to cookie session.\n    return response.cookies\n\ndef test_get_current_user_profile():\n    # First authenticate user to get valid auth cookies\n    try:\n        auth_cookies = get_auth_token(TEST_EMAIL, TEST_CODE)\n    except Exception:\n        # Cannot authenticate, fail test immediately\n        assert False, \"Authentication failed for valid user credentials\"\n    \n    profile_url = f\"{BASE_URL}/api/users/me\"\n    headers = {\"Accept\": \"application/json\"}\n\n    # 1) Test authorized access - valid token/cookie\n    response = requests.get(profile_url, headers=headers, cookies=auth_cookies, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n    json_data = response.json()\n    # Validate keys existence in response\n    expected_keys = {\"id\", \"email\", \"firstName\", \"lastName\", \"role\"}\n    assert expected_keys.issubset(json_data.keys()), f\"Response missing keys: {expected_keys - set(json_data.keys())}\"\n    # Validate value types\n    assert isinstance(json_data[\"id\"], str) and json_data[\"id\"], \"id should be non-empty string\"\n    assert isinstance(json_data[\"email\"], str) and \"@\" in json_data[\"email\"], \"email should be valid string containing '@'\"\n    assert isinstance(json_data[\"firstName\"], str), \"firstName should be string\"\n    assert isinstance(json_data[\"lastName\"], str), \"lastName should be string\"\n    assert isinstance(json_data[\"role\"], str) and json_data[\"role\"] in {\"admin\", \"user\"}, \"role should be 'admin' or 'user'\"\n\n    # 2) Test unauthorized access - no auth token/cookie\n    response_unauth = requests.get(profile_url, headers=headers, timeout=TIMEOUT)\n    assert response_unauth.status_code == 401, f\"Expected 401 Unauthorized when no auth, got {response_unauth.status_code}\"\n\n\ntest_get_current_user_profile()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 27, in test_get_current_user_profile\n  File \"<string>\", line 15, in get_auth_token\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 500 Server Error: Internal Server Error for url: http://localhost:3000/api/auth/verify-code\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 54, in <module>\n  File \"<string>\", line 30, in test_get_current_user_profile\nAssertionError: Authentication failed for valid user credentials\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.648Z",
    "modified": "2025-10-30T02:42:34.729Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "59b41ad1-b916-4390-9686-865ae47d05ed",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC004-update_user_profile_with_email_change_verification",
    "description": "Test updating user profile fields including firstName, lastName, email, position, and company. Validate email change triggers verification process. Check validation errors, unauthorized access, and email conflict handling.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_update_user_profile_with_email_change_verification():\n    # Use test user credentials\n    test_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    test_code = None\n    headers = {}\n\n    # Step 1: Send verification code to login user and get code (simulate external process)\n    try:\n        # Send code request\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/send-code\",\n            json={\"email\": test_email},\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 200, f\"Send code failed: {resp.text}\"\n        data = resp.json()\n        assert data.get(\"success\") is True, \"Send code response missing success true\"\n        assert \"token\" in data, \"Send code response missing token\"\n        # The token here is not JWT for auth, so we continue to get code via test assumption\n    except Exception as e:\n        raise AssertionError(f\"Failed to send verification code: {str(e)}\")\n\n    # For test purpose, assume code is \"123456\" (since real email intercept not possible here)\n    # In real environment, it should be fetched by other means.\n    test_code = \"123456\"\n\n    # Step 2: Verify code and login user\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/verify-code\",\n            json={\"email\": test_email, \"code\": test_code},\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 200, f\"Verify code failed: {resp.text}\"\n        verify_data = resp.json()\n        assert verify_data.get(\"success\") is True, \"Verify code response missing success true\"\n        assert \"user\" in verify_data, \"Verify code response missing user\"\n        # Extract cookies (HttpOnly) with JWT token for auth\n        cookies = resp.cookies\n        assert cookies, \"No cookies set in verify code response\"\n        headers = {\"Cookie\": \"; \".join([f\"{c.name}={c.value}\" for c in cookies])}\n    except Exception as e:\n        raise AssertionError(f\"Failed to verify code and login: {str(e)}\")\n\n    # Step 3: Get current user profile to obtain existing data\n    try:\n        resp = requests.get(f\"{BASE_URL}/api/users/me\", headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Get user profile failed: {resp.text}\"\n        profile = resp.json()\n        assert \"email\" in profile and profile[\"email\"] == test_email, \"User profile email mismatch\"\n    except Exception as e:\n        raise AssertionError(f\"Failed to get current user profile: {str(e)}\")\n\n    # Prepare update payload with changed details\n    updated_email = f\"updated_{uuid.uuid4().hex[:8]}@example.com\"\n    update_payload = {\n        \"firstName\": \"UpdatedFirst\",\n        \"lastName\": \"UpdatedLast\",\n        \"email\": updated_email,\n        \"position\": \"Tester\",\n        \"company\": \"TestCompany Inc\",\n    }\n\n    # Step 4: Update user profile successfully\n    try:\n        resp = requests.put(\n            f\"{BASE_URL}/api/users/me\",\n            headers={**headers, \"Content-Type\": \"application/json\"},\n            json=update_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 200, f\"Update profile failed: {resp.text}\"\n    except Exception as e:\n        raise AssertionError(f\"Failed to update user profile: {str(e)}\")\n\n    # Step 5: Confirm email change triggers verification process (try to send code to new email)\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/send-code\",\n            json={\"email\": updated_email},\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 200, f\"Send code to updated email failed: {resp.text}\"\n        send_code_resp = resp.json()\n        assert send_code_resp.get(\"success\") is True, \"Send code to updated email did not succeed\"\n    except Exception as e:\n        raise AssertionError(f\"Email change verification not triggered: {str(e)}\")\n\n    # Step 6: Validation error - send bad payload (email invalid format)\n    invalid_payload = {\n        \"firstName\": \"BadName\",\n        \"lastName\": \"BadLast\",\n        \"email\": \"not-an-email\",\n        \"position\": \"Invalid\",\n        \"company\": \"InvalidCo\",\n    }\n    try:\n        resp = requests.put(\n            f\"{BASE_URL}/api/users/me\",\n            headers={**headers, \"Content-Type\": \"application/json\"},\n            json=invalid_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 400, \"Expected 400 validation error for bad email format\"\n    except AssertionError as e:\n        raise\n    except Exception as e:\n        raise AssertionError(f\"Failed to handle validation error: {str(e)}\")\n\n    # Step 7: Unauthorized access - no auth headers\n    try:\n        resp = requests.put(\n            f\"{BASE_URL}/api/users/me\",\n            headers={\"Content-Type\": \"application/json\"},\n            json=update_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 401, \"Expected 401 Unauthorized without auth headers\"\n    except AssertionError as e:\n        raise\n    except Exception as e:\n        raise AssertionError(f\"Failed to handle unauthorized update: {str(e)}\")\n\n    # Step 8: Email conflict handling\n    # First, create another user with an email that will conflict\n    conflict_email = f\"conflict_{uuid.uuid4().hex[:8]}@example.com\"\n    try:\n        # Send code to conflict email\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/send-code\",\n            json={\"email\": conflict_email},\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 200, f\"Send code failed for conflict user: {resp.text}\"\n        # Verify code to create user\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/verify-code\",\n            json={\"email\": conflict_email, \"code\": \"123456\"},\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 200, f\"Verify code failed for conflict user: {resp.text}\"\n    except Exception as e:\n        raise AssertionError(f\"Failed to create conflict user: {str(e)}\")\n\n    # Try updating original user profile email to conflict_email\n    conflict_payload = update_payload.copy()\n    conflict_payload[\"email\"] = conflict_email\n    try:\n        resp = requests.put(\n            f\"{BASE_URL}/api/users/me\",\n            headers={**headers, \"Content-Type\": \"application/json\"},\n            json=conflict_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 409, \"Expected 409 Conflict when using existing email\"\n    except AssertionError as e:\n        raise\n    except Exception as e:\n        raise AssertionError(f\"Failed to handle email conflict: {str(e)}\")\n\ntest_update_user_profile_with_email_change_verification()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 21, in test_update_user_profile_with_email_change_verification\nAssertionError: Send code failed: {\"success\":false,\"error\":\"Внутренняя ошибка сервера\"}\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 167, in <module>\n  File \"<string>\", line 27, in test_update_user_profile_with_email_change_verification\nAssertionError: Failed to send verification code: Send code failed: {\"success\":false,\"error\":\"Внутренняя ошибка сервера\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.653Z",
    "modified": "2025-10-30T02:42:34.705Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "c4554cfc-2c01-4044-ac3f-0ca8bf4ee7fa",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC005-list_user_organizations",
    "description": "Test retrieving the list of organizations associated with the authenticated user. Validate response structure and unauthorized access handling.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_list_user_organizations():\n    \"\"\"\n    Test retrieving the list of organizations associated with the authenticated user.\n    Validate response structure and unauthorized access handling.\n    \"\"\"\n    # Sample credentials for authentication - replace with valid email and code for real test\n    email = \"testuser@example.com\"\n    \n    try:\n        # Step 1: Send verification code to email\n        send_code_resp = requests.post(\n            f\"{BASE_URL}/api/auth/send-code\",\n            json={\"email\": email},\n            timeout=TIMEOUT,\n        )\n        assert send_code_resp.status_code == 200, f\"Send code failed: {send_code_resp.text}\"\n        send_code_data = send_code_resp.json()\n        assert send_code_data.get(\"success\") is True, \"Send code success flag is False\"\n        assert \"token\" in send_code_data, \"No token returned on send-code\"\n\n        # Since the actual code is sent externally, we assume here for test purposes a valid code \"123456\"\n        # In real scenarios, the code must be retrieved from email or test mocks\n        code = \"123456\"\n\n        # Step 2: Verify code and login user\n        verify_code_resp = requests.post(\n            f\"{BASE_URL}/api/auth/verify-code\",\n            json={\"email\": email, \"code\": code},\n            timeout=TIMEOUT,\n        )\n        assert verify_code_resp.status_code == 200, f\"Verify code failed: {verify_code_resp.text}\"\n        verify_code_data = verify_code_resp.json()\n        assert verify_code_data.get(\"success\") is True, \"Verify code success flag is False\"\n        assert \"user\" in verify_code_data, \"No user info in verify code response\"\n\n        # Extract cookies (HttpOnly assumed) for authenticated requests\n        cookies = verify_code_resp.cookies\n\n        # Step 3: Authorized request - list organizations\n        orgs_resp = requests.get(\n            f\"{BASE_URL}/api/organizations\",\n            cookies=cookies,\n            timeout=TIMEOUT,\n        )\n        assert orgs_resp.status_code == 200, f\"Authorized orgs list failed: {orgs_resp.text}\"\n        orgs_data = orgs_resp.json()\n        assert isinstance(orgs_data, list), \"Organizations response is not a list\"\n\n        # Optional: Validate each organization object is dict\n        for org in orgs_data:\n            assert isinstance(org, dict), \"Organization item is not a dict\"\n\n        # Step 4: Unauthorized request - without cookies\n        unauthorized_resp = requests.get(\n            f\"{BASE_URL}/api/organizations\",\n            timeout=TIMEOUT,\n        )\n        assert unauthorized_resp.status_code == 401, (\n            f\"Unauthorized access should return 401, got {unauthorized_resp.status_code}\"\n        )\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed with exception: {e}\"\n\ntest_list_user_organizations()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 70, in <module>\n  File \"<string>\", line 21, in test_list_user_organizations\nAssertionError: Send code failed: {\"success\":false,\"error\":\"Внутренняя ошибка сервера\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.658Z",
    "modified": "2025-10-30T02:42:33.709Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "71e6e440-8bbf-4699-b0e6-c389027233b6",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC006-create_organization_with_valid_requisites",
    "description": "Test creating a new organization with valid fields such as name_full, inn, and address_legal. Validate JSON schema and business rules for requisites. Check for validation errors and unauthorized access.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Placeholder token for authenticated requests; in real scenarios this should be obtained via auth flow\nAUTH_TOKEN = \"Bearer your_valid_jwt_token_here\"\n\ndef create_organization_payload():\n    unique_suffix = str(uuid.uuid4())[:8]\n    return {\n        \"name_full\": f\"Test Organization {unique_suffix}\",\n        \"inn\": \"7707083893\",  # Example valid INN for a Russian organization (10 digits)\n        \"address_legal\": \"123 Test St, Test City, Test Country\"\n    }\n\ndef test_create_organization_with_valid_requisites():\n    headers_auth = {\n        \"Authorization\": AUTH_TOKEN,\n        \"Content-Type\": \"application/json\"\n    }\n    \n    headers_unauth = {\n        \"Content-Type\": \"application/json\"\n    }\n    \n    payload = create_organization_payload()\n    \n    # Test unauthorized access (no Authorization header)\n    try:\n        response = requests.post(f\"{BASE_URL}/api/organizations\", json=payload, headers=headers_unauth, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Request to create organization without auth failed unexpectedly: {e}\"\n    else:\n        assert response.status_code == 401, f\"Expected 401 Unauthorized for no auth, got {response.status_code}\"\n    \n    # Test creating organization with valid requisites\n    org_id = None\n    try:\n        response = requests.post(f\"{BASE_URL}/api/organizations\", json=payload, headers=headers_auth, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Request to create organization failed: {e}\"\n    \n    assert response.status_code == 201, f\"Expected 201 Created, got {response.status_code} with body {response.text}\"\n    \n    try:\n        data = response.json()\n    except Exception as e:\n        assert False, f\"Response is not valid JSON: {e}\"\n    \n    # Validate that response contains at least an ID or some identifier\n    # Since schema not explicitly given for response body, assume it returns object including 'id'\n    org_id = data.get(\"id\")\n    assert org_id is not None and isinstance(org_id, str) and org_id.strip() != \"\", \"Response missing valid organization ID\"\n    \n    # Validate response fields match input (name_full, inn, address_legal)\n    assert data.get(\"name_full\") == payload[\"name_full\"], \"name_full in response does not match request\"\n    assert data.get(\"inn\") == payload[\"inn\"], \"inn in response does not match request\"\n    assert data.get(\"address_legal\") == payload[\"address_legal\"], \"address_legal in response does not match request\"\n    \n    # Additional business rules checks could be done here if API returns relevant details or errors\n    \n    # Test validation error by sending invalid INN (e.g., incorrect format)\n    invalid_payload = payload.copy()\n    invalid_payload[\"inn\"] = \"123\"  # invalid INN (too short)\n    try:\n        response_invalid = requests.post(f\"{BASE_URL}/api/organizations\", json=invalid_payload, headers=headers_auth, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Request with invalid INN failed unexpectedly: {e}\"\n    else:\n        assert response_invalid.status_code == 400, f\"Expected 400 Validation error for invalid INN, got {response_invalid.status_code}\"\n    \n    # Cleanup: delete the created organization\n    if org_id:\n        try:\n            del_response = requests.delete(f\"{BASE_URL}/api/organizations/{org_id}\", headers=headers_auth, timeout=TIMEOUT)\n        except Exception as e:\n            assert False, f\"Cleanup delete organization failed: {e}\"\n        else:\n            assert del_response.status_code == 200, f\"Expected 200 on delete, got {del_response.status_code}\"\n\ntest_create_organization_with_valid_requisites()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 83, in <module>\n  File \"<string>\", line 45, in test_create_organization_with_valid_requisites\nAssertionError: Expected 201 Created, got 401 with body {\"error\":\"Unauthorized\",\"message\":\"Invalid or expired token\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.662Z",
    "modified": "2025-10-30T02:42:34.731Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "51edaec0-f2c0-420a-a9e1-323136b6e7ba",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC007-get_organization_by_id",
    "description": "Test retrieving organization details by valid ID. Validate response content and handling of unauthorized access and not found errors.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\n# Set this to a valid Bearer token with appropriate permissions for the test user:\nAUTH_TOKEN = \"Bearer YOUR_VALID_JWT_TOKEN_HERE\"\n\ndef test_get_organization_by_id():\n    headers = {\n        \"Authorization\": AUTH_TOKEN,\n        \"Content-Type\": \"application/json\"\n    }\n    org_data = {\n        \"name_full\": f\"Test Organization {uuid.uuid4()}\",\n        \"inn\": \"1234567890\",\n        \"address_legal\": \"123 Test St, Test City\"\n    }\n    org_id = None\n    try:\n        # Create organization to get a valid ID for test\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/organizations\",\n            json=org_data,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Create org failed: {create_resp.text}\"\n        created_org = create_resp.json()\n        assert isinstance(created_org, dict)\n        if \"id\" in created_org:\n            org_id = created_org[\"id\"]\n        else:\n            # If API does not return id, try to get organizations list and find it by name_full\n            list_resp = requests.get(f\"{BASE_URL}/api/organizations\", headers=headers, timeout=TIMEOUT)\n            assert list_resp.status_code == 200\n            orgs = list_resp.json()\n            orgs_by_name = [org for org in orgs if org.get(\"name_full\") == org_data[\"name_full\"]]\n            assert len(orgs_by_name) == 1\n            org_id = orgs_by_name[0][\"id\"]\n        # Test GET organization by valid ID\n        get_resp = requests.get(f\"{BASE_URL}/api/organizations/{org_id}\", headers=headers, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Get org by id failed: {get_resp.text}\"\n        org_detail = get_resp.json()\n        assert org_detail.get(\"id\") == org_id\n        assert org_detail.get(\"name_full\") == org_data[\"name_full\"]\n        assert org_detail.get(\"inn\") == org_data[\"inn\"]\n        assert org_detail.get(\"address_legal\") == org_data[\"address_legal\"]\n\n        # Test GET organization by invalid ID returns 404\n        fake_id = \"00000000-0000-0000-0000-000000000000\"\n        not_found_resp = requests.get(f\"{BASE_URL}/api/organizations/{fake_id}\", headers=headers, timeout=TIMEOUT)\n        assert not_found_resp.status_code == 404\n\n        # Test GET organization without auth returns 401\n        unauth_resp = requests.get(f\"{BASE_URL}/api/organizations/{org_id}\", timeout=TIMEOUT)\n        assert unauth_resp.status_code == 401 or unauth_resp.status_code == 403\n\n    finally:\n        if org_id:\n            # Clean up created organization\n            requests.delete(f\"{BASE_URL}/api/organizations/{org_id}\", headers=headers, timeout=TIMEOUT)\n\n\ntest_get_organization_by_id()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 66, in <module>\n  File \"<string>\", line 29, in test_get_organization_by_id\nAssertionError: Create org failed: {\"error\":\"Unauthorized\",\"message\":\"Invalid or expired token\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.669Z",
    "modified": "2025-10-30T02:42:37.798Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "d7e432de-f765-4528-941f-791498eab9d6",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC008-update_organization_with_validation",
    "description": "Test updating an existing organization by ID with valid data. Validate JSON schema and business rules. Check for validation errors, unauthorized access, and not found errors.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nORG_ENDPOINT = f\"{BASE_URL}/api/organizations\"\nTIMEOUT = 30\n\n# Dummy auth token - replace with valid token for real testing\nAUTH_TOKEN = \"Bearer your_valid_jwt_token_here\"\n\nheaders = {\n    \"Authorization\": AUTH_TOKEN,\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_update_organization_with_validation():\n    # Step 1: Create a new organization to update\n    create_payload = {\n        \"name_full\": \"Test Organization \" + str(uuid.uuid4()),\n        \"inn\": \"1234567890\",\n        \"address_legal\": \"123 Test St, Test City\"\n    }\n    org_id = None\n    try:\n        response = requests.post(ORG_ENDPOINT, json=create_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 201, f\"Failed to create organization: {response.status_code} {response.text}\"\n        created_org = response.json()\n        assert \"id\" in created_org, \"Created organization response missing 'id'\"\n        org_id = created_org[\"id\"]\n\n        # Step 2: Update the organization with valid data\n        update_payload = {\n            \"name_full\": \"Updated Organization \" + str(uuid.uuid4()),\n            \"inn\": \"0987654321\",\n            \"address_legal\": \"456 Updated Ave, New City\"\n        }\n        update_response = requests.put(f\"{ORG_ENDPOINT}/{org_id}\", json=update_payload, headers=headers, timeout=TIMEOUT)\n\n        # Check success update\n        assert update_response.status_code == 200, f\"Update failed: {update_response.status_code} {update_response.text}\"\n        updated_org = update_response.json()\n        assert updated_org.get(\"name_full\") == update_payload[\"name_full\"], \"Name not updated correctly\"\n        assert updated_org.get(\"inn\") == update_payload[\"inn\"], \"INN not updated correctly\"\n        assert updated_org.get(\"address_legal\") == update_payload[\"address_legal\"], \"Address not updated correctly\"\n\n        # Step 3: Test validation error: send invalid INN (e.g., too short)\n        invalid_payload = {\n            \"name_full\": \"Invalid Org\",\n            \"inn\": \"123\",  # Invalid INN format\n            \"address_legal\": \"789 Invalid Rd\"\n        }\n        invalid_response = requests.put(f\"{ORG_ENDPOINT}/{org_id}\", json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        assert invalid_response.status_code == 400, f\"Expected 400 for validation error but got {invalid_response.status_code}\"\n\n        # Step 4: Test unauthorized access (no token)\n        no_auth_response = requests.put(f\"{ORG_ENDPOINT}/{org_id}\", json=update_payload, headers={\"Content-Type\": \"application/json\"}, timeout=TIMEOUT)\n        assert no_auth_response.status_code == 401, f\"Expected 401 Unauthorized but got {no_auth_response.status_code}\"\n\n        # Step 5: Test not found error (non-existent ID)\n        fake_id = str(uuid.uuid4())\n        not_found_response = requests.put(f\"{ORG_ENDPOINT}/{fake_id}\", json=update_payload, headers=headers, timeout=TIMEOUT)\n        assert not_found_response.status_code == 404, f\"Expected 404 Not Found but got {not_found_response.status_code}\"\n\n    finally:\n        # Clean up: delete created organization if exists\n        if org_id:\n            try:\n                del_response = requests.delete(f\"{ORG_ENDPOINT}/{org_id}\", headers=headers, timeout=TIMEOUT)\n                assert del_response.status_code == 200 or del_response.status_code == 404, f\"Failed to delete organization: {del_response.status_code}\"\n            except Exception:\n                pass\n\ntest_update_organization_with_validation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 75, in <module>\n  File \"<string>\", line 28, in test_update_organization_with_validation\nAssertionError: Failed to create organization: 401 {\"error\":\"Unauthorized\",\"message\":\"Invalid or expired token\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.674Z",
    "modified": "2025-10-30T02:42:41.326Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "ee121a8f-070e-455e-84e7-a9ba26899ddb",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC009-delete_organization_by_id",
    "description": "Test deleting an organization by valid ID. Validate successful deletion response and handling of not found errors.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": \"Bearer YOUR_JWT_TOKEN\"  # Replace with valid JWT token\n}\n\ndef test_delete_organization_by_id():\n    org_data = {\n        \"name_full\": f\"Test Organization {uuid.uuid4()}\",\n        \"inn\": \"7707083893\",\n        \"address_legal\": \"123 Test St, Test City\"\n    }\n\n    created_org_id = None\n    # Create a new organization to delete\n    try:\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/organizations\",\n            json=org_data,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Failed to create organization, status {create_resp.status_code}\"\n        created_org_id = create_resp.json().get(\"id\")\n        assert created_org_id, \"Response JSON missing organization id\"\n\n        # Delete the created organization\n        delete_resp = requests.delete(\n            f\"{BASE_URL}/api/organizations/{created_org_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert delete_resp.status_code == 200, f\"Failed to delete organization, status {delete_resp.status_code}\"\n\n        # Confirm deletion: requesting the same organization should return 404\n        get_deleted_resp = requests.get(\n            f\"{BASE_URL}/api/organizations/{created_org_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_deleted_resp.status_code == 404, f\"Deleted organization still accessible, status {get_deleted_resp.status_code}\"\n\n        # Try deleting a non-existent organization ID\n        fake_id = str(uuid.uuid4())\n        del_fake_resp = requests.delete(\n            f\"{BASE_URL}/api/organizations/{fake_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert del_fake_resp.status_code == 404, f\"Deleting non-existent organization should return 404, got {del_fake_resp.status_code}\"\n\n    finally:\n        # Cleanup in case deletion failed in test: attempt to delete if exists\n        if created_org_id:\n            requests.delete(\n                f\"{BASE_URL}/api/organizations/{created_org_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n\ntest_delete_organization_by_id()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 65, in <module>\n  File \"<string>\", line 27, in test_delete_organization_by_id\nAssertionError: Failed to create organization, status 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.679Z",
    "modified": "2025-10-30T02:42:52.941Z"
  },
  {
    "projectId": "5dfba65f-30f6-479e-a357-ce547d73665b",
    "testId": "68bc2025-3693-47dc-b975-877c3e2a2e56",
    "userId": "9428b488-e051-70e4-f4c6-21edfb9a7dca",
    "title": "TC010-create_new_document_with_template_support",
    "description": "Test creating a new document with required templateCode and optional organizationId, title, and bodyText. Validate access period and demo limits enforcement. Check for validation errors, unauthorized access, and access denied responses.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_create_new_document_with_template_support():\n    # Use test email and code for authentication (replace with valid test credentials)\n    test_email = \"testuser@example.com\"\n    test_code = \"123456\"  # Replace with valid code or mock\n    \n    session = requests.Session()\n    try:\n        # Authenticate user and get cookies for session\n        send_code_resp = session.post(\n            f\"{BASE_URL}/api/auth/send-code\",\n            json={\"email\": test_email},\n            timeout=TIMEOUT\n        )\n        assert send_code_resp.status_code == 200\n        assert send_code_resp.json().get(\"success\") is True\n\n        verify_resp = session.post(\n            f\"{BASE_URL}/api/auth/verify-code\",\n            json={\"email\": test_email, \"code\": test_code},\n            timeout=TIMEOUT\n        )\n        assert verify_resp.status_code == 200\n        verify_json = verify_resp.json()\n        assert verify_json.get(\"success\") is True\n\n        headers = {\"Content-Type\": \"application/json\"}\n\n        # Step 1: Get enabled templates to ensure valid templateCode input\n        templates_resp = session.get(f\"{BASE_URL}/api/templates\", timeout=TIMEOUT)\n        assert templates_resp.status_code == 200\n        templates = templates_resp.json()\n        assert isinstance(templates, list)\n        assert len(templates) > 0\n        template_code = templates[0].get(\"code\")\n        assert template_code is not None, \"No valid templateCode found from templates\"\n\n        # Step 2: Get user's organizations to pick optional organizationId if any\n        orgs_resp = session.get(f\"{BASE_URL}/api/organizations\", timeout=TIMEOUT)\n        assert orgs_resp.status_code in (200, 401)\n        organization_id = None\n        if orgs_resp.status_code == 200:\n            orgs = orgs_resp.json()\n            if isinstance(orgs, list) and len(orgs) > 0 and \"id\" in orgs[0]:\n                organization_id = orgs[0][\"id\"]\n\n        # Prepare payloads for various cases\n\n        # Successful creation with minimum required field (templateCode only)\n        payload_minimal = {\n            \"templateCode\": template_code\n        }\n\n        # Successful creation with all optional fields\n        payload_full = {\n            \"templateCode\": template_code,\n            \"organizationId\": organization_id,\n            \"title\": \"Test Document Title\",\n            \"bodyText\": \"Sample text body for the document.\"\n        }\n\n        # 1) Test successful creation minimal\n        resp = session.post(f\"{BASE_URL}/api/documents\", json=payload_minimal, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Expected 201 Created, got {resp.status_code}\"\n        doc1 = resp.json()\n        assert isinstance(doc1, dict)\n        assert \"id\" in doc1\n\n        # 2) Test successful creation full\n        resp = session.post(f\"{BASE_URL}/api/documents\", json=payload_full, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 201, f\"Expected 201 Created, got {resp.status_code}\"\n        doc2 = resp.json()\n        assert isinstance(doc2, dict)\n        assert \"id\" in doc2\n\n        # 3) Test validation error: missing required templateCode\n        payload_invalid = {\n            \"title\": \"Missing TemplateCode\"\n        }\n        resp = session.post(f\"{BASE_URL}/api/documents\", json=payload_invalid, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 400\n\n        # 4) Test unauthorized access (without authentication)\n        session_no_auth = requests.Session()\n        resp = session_no_auth.post(f\"{BASE_URL}/api/documents\", json=payload_minimal, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 401\n\n        # 5) Test access denied or limit exceeded\n        payload_forbidden = {\n            \"templateCode\": \"invalid_template_code_to_trigger_403\"\n        }\n        resp = session.post(f\"{BASE_URL}/api/documents\", json=payload_forbidden, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code in (403, 400)  # Could be forbidden or validation error\n\n    finally:\n        pass\n\ntest_create_new_document_with_template_support()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 102, in <module>\n  File \"<string>\", line 19, in test_create_new_document_with_template_support\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-30T02:41:40.684Z",
    "modified": "2025-10-30T02:43:18.345Z"
  }
]
